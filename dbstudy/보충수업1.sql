-- 1. DEPARTMENT_ID가 20인 사원중에서 전체 평균 연봉(SALARY) 이상을 받는 사원의 EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, SALARY를 조회하시오.
--    서브쿼리 : 전체 사원들의 평균 연봉
--    메인쿼리 : SELECT 칼럼 FROM 테이블 WHERE DEPARTMENT_ID=20 AND 연봉 >= (서브쿼리)
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, SALARY
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID = 20
   AND SALARY >= (SELECT AVG(SALARY)
                    FROM EMPLOYEES);

-- 2. JOB_ID가 'IT_PROG'인 사원의 최대 연봉(SALARY)보다 더 많은 연봉을 받는 사원의 EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY를 조회하시오.
--    서브쿼리 : JOB_ID가 'IT_PROG'인 사원의 최대 연봉(SALARY)
--    메인쿼리 : SELECT 칼럼 FROM 테이블 WHERE 연봉 > (서브쿼리)
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY
  FROM EMPLOYEES
 WHERE SALARY > (SELECT MAX(SALARY)
                   FROM EMPLOYEES
                  WHERE JOB_ID = 'IT_PROG');

-- 3. EMPLOYEE_ID가 115인 사원과 같은 JOB_ID, DEPARTMENT_ID를 가진 사원의 EMPLOYEE_ID, FIRST_NAME, JOB_ID, DEPARTMENT_ID를 조회하시오.
--    JOB_ID = X AND DEPARTMENT_ID = Y
--    (JOB_ID, DEPARTMENT_ID) = (X, Y)
--    서브쿼리 : EMPLOYEE_ID가 115인 사원의 JOB_ID, DEPARTMENT_ID
--    메인쿼리 : SELECT 칼럼 FROM 테이블 WHERE (JOB_ID, DEPARTMENT_ID) = (서브쿼리)
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, DEPARTMENT_ID
  FROM EMPLOYEES
 WHERE (JOB_ID, DEPARTMENT_ID) = (SELECT JOB_ID, DEPARTMENT_ID
                                    FROM EMPLOYEES
                                   WHERE EMPLOYEE_ID = 115);

-- 4. LOCATION_ID가 1000~1500인 국가들의 COUNTRY_ID, COUNTRY_NAME을 조회하시오.
--    LOCATIONS(*LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVICCE, COUNTRY_ID)
--    COUNTRIES(*COUNTRY_ID, COUNTRY_NAME, REGION_ID)

-- 조인
SELECT DISTINCT L.COUNTRY_ID, C.COUNTRY_NAME
  FROM COUNTRIES C INNER JOIN LOCATIONS L
    ON C.COUNTRY_ID = L.COUNTRY_ID
 WHERE L.LOCATION_ID BETWEEN 1000 AND 1500;

-- 서브쿼리 : LOCATION_ID가 1000~1500인 지역의 COUNTRY_ID(다중 행 서브쿼리)
-- 메인쿼리 : SELECT 칼럼 FROM COUNTRIES WHERE COUNTRY_ID IN(서브쿼리)
SELECT COUNTRY_ID, COUNTRY_NAME
  FROM COUNTRIES
 WHERE COUNTRY_ID IN(SELECT COUNTRY_ID
                       FROM LOCATIONS
                      WHERE LOCATION_ID BETWEEN 1000 AND 1500);


-- 5. MANAGER가 아닌 사원들의 EMPLOYEE_ID, FIRST_NAME을 조회하시오.
--    (참고. 서브쿼리 결과는 NULL을 포함하면 안 된다.)
--    서브쿼리 : 중복이 제거된 MANAGER_ID(다중 행 서브쿼리)
--    메인쿼리 : SELECT 칼럼 FROM EMPLOYEES WHERE EMPLOYEE_ID NOT IN(서브쿼리)
SELECT EMPLOYEE_ID, FIRST_NAME
  FROM EMPLOYEES
 WHERE EMPLOYEE_ID NOT IN(SELECT DISTINCT MANAGER_ID
                            FROM EMPLOYEES
                           WHERE MANAGER_ID IS NOT NULL);


-- 6. 근무하는 CITY가 'Southlake'인 사원들의 EMPLOYEE_ID, FIRST_NAME를 조회하시오.

-- 조인
SELECT E.EMPLOYEE_ID, E.FIRST_NAME
  FROM LOCATIONS L INNER JOIN DEPARTMENTS D
    ON L.LOCATION_ID = D.LOCATION_ID INNER JOIN EMPLOYEES E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
 WHERE L.CITY = 'Southlake';

-- 서브쿼리
SELECT EMPLOYEE_ID, FIRST_NAME
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN(SELECT DEPARTMENT_ID
                          FROM DEPARTMENTS
                         WHERE LOCATION_ID IN(SELECT LOCATION_ID
                                                FROM LOCATIONS
                                               WHERE CITY = 'Southlake'));  -- CITY는 PK/UNIQUE 아니므로 다중 행 서브쿼리


-- 7. 가장 많은 사원이 근무 중인 부서의 DEPARTMENT_ID, 근무 인원 수를 조회하시오.
--    서브쿼리 : 가장 많은 사원이 근무 중인 부서의 근무 인원수 - MAX(부서별 근무 중인 인원수)
--    메인쿼리 : SELECT DEPARTMENT_ID, 근무인원수 FROM EMPLOYEES GROUP BY DEPARTMENT_ID HAVING 부서별인원수 = (서브쿼리)
SELECT DEPARTMENT_ID, COUNT(*)
  FROM EMPLOYEES
 GROUP BY DEPARTMENT_ID
HAVING COUNT(*) = (SELECT MAX(COUNT(*))
                     FROM EMPLOYEES
                    GROUP BY DEPARTMENT_ID);

-- 수업에서 언급한 함수를 이용해 봅니다.
-- 1) 부서별로 그룹화하여 부서별 인원수를 조회한다.
-- 2) 조회된 데이터를 인원수가 큰 순으로 내림차순 정렬한다.
-- 2) 내림차순 정렬하면 가장 큰 인원수가 첫 번째 목록이 되므로 첫 번째 데이터만 조회한다.
SELECT DEPARTMENT_ID, CNT
  FROM (SELECT DEPARTMENT_ID, CNT
          FROM (SELECT DISTINCT DEPARTMENT_ID, COUNT(*) OVER(PARTITION BY DEPARTMENT_ID) AS CNT
                  FROM EMPLOYEES)
        ORDER BY CNT DESC)
 WHERE ROWNUM = 1;


-- 8. DEPARTMENT_NAME의 오름차순 정렬 기준으로 사원의 EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID를 조회하시오.
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, D.DEPARTMENT_ID
  FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
 ORDER BY D.DEPARTMENT_NAME;


-- 9. 최대 연봉 사원의 EMPLOYEE_ID, FIRST_NAME, SALARY를 조회하시오.
--    1) ROWNUM 활용
--       (1) 높은 연봉이 가장 위로 오도록 정렬한다. (연봉 내림차순 정렬)
--       (2) 정렬 결과에서 ROWNUM이 1인 데이터를 조회한다.
SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.SALARY
 FROM (SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
         FROM EMPLOYEES
        ORDER BY SALARY DESC) A
 WHERE ROWNUM = 1;

--    2) RANK() OVER() 활용
--       (1) 높은 연봉이 1등이 되도록 RANK() 함수를 구한다.
--       (2) RANK() 함수 결과가 1인 데이터를 조회한다.
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
  FROM (SELECT RANK() OVER(ORDER BY SALARY DESC) AS R, EMPLOYEE_ID, FIRST_NAME, SALARY
          FROM EMPLOYEES)
 WHERE R = 1;

--    3) ROW_NUMBER() OVER() 활용
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
  FROM (SELECT ROW_NUMBER() OVER(ORDER BY SALARY DESC) AS RN, EMPLOYEE_ID, FIRST_NAME, SALARY
          FROM EMPLOYEES)
 WHERE RN = 1;


-- 10. 연봉 TOP 11 ~ 20 사원의 EMPLOYEE_ID, FIRST_NAME, SALARY를 조회하시오.
--     1) ROWNUM 활용
--        (1) 높은 연봉이 가장 위로 오도록 정렬한다. (연봉 내림차순 정렬)
--        (2) 정렬 결과에 ROWNUM 칼럼을 추가한다. 반드시 ROWNUM 칼럼에 별명을 부여한다.
--        (3) 부여된 ROWNUM의 별명으로 11 ~ 20 사이를 조회한다.

-- A : 연봉 순으로 정렬한 테이블
-- B : 정렬된 테이블에 ROWNUM을 추가한 테이블

SELECT B.EMPLOYEE_ID, B.FIRST_NAME, B.SALARY
  FROM (SELECT ROWNUM AS RN, A.EMPLOYEE_ID, A.FIRST_NAME, A.SALARY
          FROM (SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
                  FROM EMPLOYEES
                 ORDER BY SALARY DESC) A) B
 WHERE B.RN BETWEEN 11 AND 20;

--    2) RANK() OVER() 활용
--       (1) 높은 연봉이 1등이 되도록 RANK() 함수를 구한다.
--       (2) RANK() 함수 결과가 11~20인 데이터를 조회한다.
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
  FROM (SELECT RANK() OVER(ORDER BY SALARY DESC) AS R, EMPLOYEE_ID, FIRST_NAME, SALARY
          FROM EMPLOYEES)
 WHERE R BETWEEN 11 AND 20;

--    3) ROW_NUMBER() OVER() 활용
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
  FROM (SELECT ROW_NUMBER() OVER(ORDER BY SALARY DESC) AS RN, EMPLOYEE_ID, FIRST_NAME, SALARY
          FROM EMPLOYEES)
 WHERE RN BETWEEN 11 AND 20;